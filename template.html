<html>
<head>
    <title>template threejs</title>
    <style>
        body { margin: 0; }
        canvas { width: 100%; height: 100% }
    </style>
</head>
<body>
<script src="three.js-master/build/three.min.js"></script>
<script src='js/THREEx.KeyboardState.js'></script>
<script src="js/loaders/DDSLoader.js"></script>
<script src="js/loaders/MTLLoader.js"></script>
<script src="js/loaders/OBJLoader.js"></script>
<script src="js/loaders/OBJMTLLoader.js"></script>
<script>
    // Create scene and camera
    var scene = new THREE.Scene();
    var camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.1, 1000 );
    //var camera = new THREE.OrthographicCamera( window.innerWidth / - 2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / - 2, - 100, 500 );

    var keyboard = new THREEx.KeyboardState();
    var clock = new THREE.Clock();

    var ambientLight = new THREE.AmbientLight(0x404040);
    scene.add(ambientLight);

    // Fog
    //scene.fog = new THREE.FogExp2( 0xefd1b5, 0.002 );

    var box3Array = [];

    var directionalLight = new THREE.DirectionalLight( 0xffffff, 0.5 );
    directionalLight.position.set( 0, 1, 0 );
    directionalLight.castShadow = true;
    scene.add( directionalLight );

    var renderer = new THREE.WebGLRenderer();
    renderer.setSize( window.innerWidth, window.innerHeight );
    document.body.appendChild( renderer.domElement );

    var geometry = new THREE.BoxGeometry( 1, 1, 1 );
    var material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
    var cube = new THREE.Mesh( geometry, material );
    cube.position.y = 0.5;
    cube.castShadow = true;
    cube.receiveShadow = true;
    scene.add( cube );

    var geometry2 = new THREE.PlaneGeometry(100, 100);
    var material2 = new THREE.MeshBasicMaterial({color: 0x1100FF, side: THREE.DoubleSide});
    var plane = new THREE.Mesh(geometry2, material2);
    plane.receiveShadow = true;
    plane.position.y = 0;

    // Rotate the plane to lay flat along the ground
    plane.rotateX(90 * Math.PI / 180 );

   // scene.add(plane);

    //FLOOR
    /**
     *
     *
     var floorTexture = new THREE.ImageUtils.loadTexture( 'images/checkerboard.jpg' );
     floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping;
     floorTexture.repeat.set( 10, 10 );
     var floorMaterial = new THREE.MeshBasicMaterial( { map: floorTexture, side: THREE.DoubleSide } );
     var floorGeometry = new THREE.PlaneGeometry(1000, 1000, 10, 10);
     var floor = new THREE.Mesh(floorGeometry, floorMaterial);
     floor.position.y = -0.5;
     floor.rotation.x = Math.PI / 2;
     scene.add(floor);
     */
    var floorTexture = new THREE.ImageUtils.loadTexture('objects/images/grass.jpg');
    floorTexture.wrapS = floorTexture.wrapT = THREE.MirroredRepeatWrapping;
    floorTexture.repeat.set( 200, 200);
    var floorMaterial = new THREE.MeshBasicMaterial({map: floorTexture, side: THREE.DoubleSide});
    var floorGeometry = new THREE.PlaneGeometry(1000,1000,10,10);
    var floor = new THREE.Mesh(floorGeometry, floorMaterial);

    floor.position.y = 0;
    floor.rotation.x = Math.PI / 2;
    scene.add(floor);

    //camera.lookAt(cube);
    camera.position.z = 5;
    camera.position.y = 1;

    // Skybox
    var axes = new THREE.AxisHelper(100);
    scene.add(axes);

    var urls = ["objects/images/right.png", "objects/images/left.png", "objects/images/top.png",
        "objects/images/bottom.png","objects/images/front.png","objects/images/back.png"];
    var skyGeo = new THREE.CubeGeometry(1000, 600, 1000);
    var materialArray = [];
    for (var i = 0; i < 6; i++){
        materialArray.push(new THREE.MeshBasicMaterial(
                {
                    map: THREE.ImageUtils.loadTexture(urls[i]),
                    side: THREE.BackSide
                }
        ));
    }
    var skyMaterial = new THREE.MeshFaceMaterial(materialArray);
    var skyBox = new THREE.Mesh(skyGeo, skyMaterial);
    skyBox.position.y = 49.5;
    scene.add(skyBox);


    /**
     * URLs for the objects
     *
     **/
    var houseObjURL = "objects/House/";
    var houseMTLURL = "objects/House/";
    var houseName = "House.obj";
    var houseMTL = "House.mtl";

    var onProgress = function ( xhr ) {
        if ( xhr.lengthComputable ) {
            var percentComplete = xhr.loaded / xhr.total * 100;
            console.log( Math.round(percentComplete, 2) + '% downloaded' );
        }
    };

    function loadBulba() {
        // load bulbasaur
        var bulba = new THREE.Object3D();
        var onError = function (xhr) {
        };
        THREE.Loader.Handlers.add(/\.dds$/i, new THREE.DDSLoader());
        var mtlLoader = new THREE.MTLLoader();
        mtlLoader.setBaseUrl('objects/Bulbasaur/');
        mtlLoader.setPath('objects/Bulbasaur/');
        mtlLoader.load('BR_Bulbasaur.mtl', function (materials) {
            materials.preload();
            var objLoader = new THREE.OBJLoader();
            objLoader.setMaterials(materials);
            objLoader.setPath('objects/Bulbasaur/');
            objLoader.load('Bulbasaur.obj', function (object) {
                object.position.set(0, 0, 2);
                object.scale.set(0.2, 0.2, 0.2);
                bulba.add(object);
                scene.add(bulba);
            }, onProgress, onError);
        });
        return bulba;
    }

    function loadNewBulba() {
        // load bulbasaur
        var bulba = new THREE.Object3D();
        var onError = function (xhr) {
        };
        THREE.Loader.Handlers.add(/\.dds$/i, new THREE.DDSLoader());
        var mtlLoader = new THREE.MTLLoader();
        mtlLoader.setBaseUrl('objects/TestBulba/');
        mtlLoader.setPath('objects/TestBulba/');
        mtlLoader.load('Bulba.mtl', function (materials) {
            materials.preload();
            var objLoader = new THREE.OBJLoader();
            objLoader.setMaterials(materials);
            objLoader.setPath('objects/TestBulba/');
            objLoader.load('Bulba.obj', function (object) {
                object.scale.set(1.5, 1.5, 1.5);
                object.position.set(0, 0.4, 5);
                bulba.add(object);

            }, onProgress, onError);
        });
        return bulba;
    }

    function loadLab() {
        // load bulbasaur
        var object3D = new THREE.Object3D();
        var onError = function (xhr) {
        };
        THREE.Loader.Handlers.add(/\.dds$/i, new THREE.DDSLoader());
        var mtlLoader = new THREE.MTLLoader();
        mtlLoader.setBaseUrl('objects/ElmPokemonLab/');
        mtlLoader.setPath('objects/ElmPokemonLab/');
        mtlLoader.load('ElmPokemonLab.mtl', function (materials) {
            materials.preload();
            var objLoader = new THREE.OBJLoader();
            objLoader.setMaterials(materials);
            objLoader.setPath('objects/ElmPokemonLab/');
            objLoader.load('Elm\ Pokemon\ Lab.obj', function (object) {
                object.scale.set(0.2, 0.2, 0.2);
                object.position.set(100, -1, -100);
                object3D.add(object);

            }, onProgress, onError);
        });
        return object3D;
    }

    /*
    * Create an obj and map its textures using the mtl file
    *
    * @objBaseURL: file path to where the .obj is located
    * @mtlBaseURL: file path to where the .mtl is located
    * @objName:    name of the obj file
    * @mtlName:    name of the mtl file
    * @xpos:       x position
    * @ypos:       y position
    * @zpos:       z position
    * */
    function loadOBJ(objBaseURL, mtlBaseURL, objName, mtlName, xpos, ypos, zpos) {

        // set the position to a default of zero if they are not passed in
        if (xpos == null)
            xpos = 0;

        if (ypos == null)
            ypos = 0;

        if (zpos == null)
            zpos = 0;

        var object3D = new THREE.Object3D();
        var onError = function (xhr) {
        };
        THREE.Loader.Handlers.add(/\.dds$/i, new THREE.DDSLoader());
        var mtlLoader = new THREE.MTLLoader();
        mtlLoader.setBaseUrl(mtlBaseURL);
        mtlLoader.setPath(mtlBaseURL);
        mtlLoader.load(mtlName, function (materials) {
            materials.preload();
            var objLoader = new THREE.OBJLoader();
            objLoader.setMaterials(materials);
            objLoader.setPath(objBaseURL);
            objLoader.load(objName, function (object) {
                object.scale.set(0.2, 0.2, 0.2);
                object.position.set(xpos, ypos, zpos);
                object3D.add(object);

            }, onProgress, onError);
        });
        return object3D;
    }

    function loadTree(){
        var leafMesh = new THREE.ImageUtils.loadTexture('objects/tree/');

    }

    // used for movement
    var move = function movement(){

        var delta = clock.getDelta();
        var rotateAngle = Math.PI / 2 * delta;
        var speed = 0.5;

        if( keyboard.pressed("W") ) {
            bulba.translateZ(-speed);
        }

        if( keyboard.pressed("S") ) {
            bulba.translateZ(speed);
        }

        // Create rotations to rotate the cube

        if ( keyboard.pressed("A") )
            bulba.rotateOnAxis( new THREE.Vector3(0,1,0), rotateAngle);
        if ( keyboard.pressed("D") )
            bulba.rotateOnAxis( new THREE.Vector3(0,1,0), -rotateAngle);
        cameraMovement(bulba);
    };

    function cameraMovement(cube){

        // 5 units behind and 3 units above the object
        var relativeCameraOffset = new THREE.Vector3(0, 5, 10);

        var cameraOffset = relativeCameraOffset.applyMatrix4(cube.matrixWorld);

        camera.position.set(cameraOffset.x, cameraOffset.y, cameraOffset.z);

        // face the object
        camera.lookAt(cube.position);
    }

    var render = function () {
        requestAnimationFrame( render );
        move();
        /**for (var i = 0; i < box3Array.length; i++){
            if(bulbaBox.intersectsBox(box3Array[i]))
            {
                console.log("Collision");
            }
        }**/
        //bulba.rotation.x += 0.1;
        renderer.shadowMap.enabled = true;
        renderer.render(scene, camera);

    };

    function getBox3(object){
        var box = new THREE.Box3();
        box.setFromObject(object);
        box3Array.push(box);
        scene.add(box);
    };

    function collide(object){
        for (var i = 0; i < box3Array.length; i++){
           if(object.intersectsBox(box3Array[i]))
           {
               console.log("Collision");
           }
        }
    };

    var house = loadOBJ(houseObjURL, houseMTLURL, houseName, houseMTL, -100, -0.199, -100);
    scene.add(house);
    var house2;
    var lab = loadLab();
    scene.add(lab);
    var bulba2 = loadNewBulba();
    scene.add(bulba2);
    var bulba = loadBulba();
    var bulbaBox = getBox3(bulba);
    getBox3(cube);

    console.log(bulba);
    render();

</script>
</body>
</html>